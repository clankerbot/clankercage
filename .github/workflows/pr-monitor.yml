name: PR Monitor

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main

jobs:
  check_commit_status:
    name: 'Check Commit Status'
    runs-on: ubuntu-latest
    steps:
      - name: Confirm Check Runs
        uses: actions/github-script@v7
        with:
          script: |
            // Wait for other workflows to start
            const PRE_SLEEP = 10000;
            const CHECK_SLEEP = 500;
            const MAX_DURATION = 1000 * 60 * 10; // 10 minutes

            const EXCLUDED_JOBS = [
              // Important: exclude this job itself
              'Check Commit Status',
            ];

            const { owner, repo } = context.repo;

            console.log(`Sleeping ${Math.round(PRE_SLEEP / 1000)}s to give other workflows a chance to start`);
            await sleep(PRE_SLEEP);
            const start = performance.now();

            const commit_sha = context.payload.pull_request.head.sha;
            console.log(`Checking for other workflows for commit: ${commit_sha}`);

            async function fetchCheckRuns() {
              const response = await github.rest.checks.listForRef({
                owner,
                repo,
                ref: commit_sha,
                per_page: 100
              });
              return response.data.check_runs;
            }

            async function sleep(ms) {
              return new Promise(resolve => setTimeout(resolve, ms));
            }

            let checkRuns = await fetchCheckRuns();
            console.log('Found check runs:', checkRuns.map(r => r.name));

            // Filter to non-excluded jobs
            const relevantRuns = checkRuns.filter(run => !EXCLUDED_JOBS.includes(run.name));

            // It's OK if no other workflows run (e.g., docs-only PR)
            if (relevantRuns.length === 0) {
              console.log('No other workflows to monitor - this is OK for docs-only PRs');
              return;
            }

            let inProgressFound = [];
            let failureFound = [];

            do {
              inProgressFound = [];
              failureFound = [];

              for (const { name, status, conclusion } of checkRuns) {
                if (!EXCLUDED_JOBS.includes(name)) {
                  if (status === 'in_progress' || status === 'queued' || status === 'pending') {
                    inProgressFound.push(name);
                  }
                  if (conclusion === 'failure') {
                    failureFound.push(name);
                  }
                }
              }

              if (inProgressFound.length) {
                if (performance.now() - start > MAX_DURATION) {
                  core.setFailed(`Exceeded max duration of ${Math.round(MAX_DURATION / 1000)}s`);
                  break;
                }
                const duration = Math.round((performance.now() - start) / 1000);
                console.log(`In progress: ${JSON.stringify(inProgressFound)} | duration: ${duration}s`);
                await sleep(CHECK_SLEEP);
                checkRuns = await fetchCheckRuns();
              }
            } while (inProgressFound.length);

            if (failureFound.length) {
              core.setFailed(`Failed check runs: ${JSON.stringify(failureFound)}`);
            } else {
              console.log('All workflows completed successfully');
            }
